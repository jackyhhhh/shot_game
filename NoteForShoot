项目案例：shooting game
1.需求：
英雄机发射子弹可以打敌人（小敌机、大敌机、小蜜蜂）
打掉大敌机-----玩家得3分
打掉小敌机-----玩家得1分
打掉小蜜蜂-----英雄机得奖励（1条命、40火力值）

英雄机默认1条命，得命则命数增1
英雄机默认火力值为0（单倍火力）
得一次火力则火力值增40
发一次双倍火力，则火力值减2

英雄机死一次，则命数减1，同时火力值清零
命数为0，则游戏结束

2.设计对象类：
  1)找对象：英雄机、小敌机、大敌机、
  			小蜜蜂、子弹、天空（背景）
  2)抽出类：Hero,Airplane,BigAirplane,Bee,Bullet,Sky
  3)创建类中的成员变量和方法
  4)创建对象并测试:World
  
 3.static
 	1)每个对象都有图片属性
 		------因为每个对象都不同,所以放在派生类中
 	2)每个对象都能读取图片
 		------每个对象读取的方式是相同的,所以放在超类中
 		
 		
-------------------------------------
oo.day07:
1.敌人(小敌机+大敌机+小蜜蜂)入场--------------------------------定时触发
	1)创建敌人对象
	2) 将敌人对象添加到enemies数组中
2.飞行物(天空+英雄机+子弹+小敌机+大敌机+小蜜蜂)移动--------------定时触发
3.子弹入场-----------------------------------------------------定时触发
	1)创建子弹对象----英雄机发射出来的
	2) 将子弹对象添加到bullets数组中	
4.英雄机随着鼠标移动--------------------------------------------事件触发
5.删除越界的飞行物----------------------------------------------定时触发

套路:
1)完成功能是,先去看是谁的行为
	1.1)所有派生类都有的行为,就写在超类FlyingObject中
		1.1.1)所有派生类行为都一样,设计为普通方法
		1.1.2)所有派生类行为不一样,设计为抽象方法
	1.2)若是派生类所特有的行为,写在具体的派生类中
2)在world类中调用方法即可
	2.1)定时触发的,在run()中调用
	2.2)事件触发的,就写在侦听器中
	
paitn()方法被调用,有两种方式:
1)frame.setVisible(true);
2)repaint();
	
调试有两种方式:
1)打桩:System.out.println(数据);
2)Debug调试工具:
	
	
swing事件相关:
1)事件:发生了一个事
2)事件处理:发生事之后所做的操作
3)侦听器:
	3.1)先创建一个侦听器对象
	3.2)将侦听器对象装到面板上

事件   			事件处理
鼠标点击			从启动状态变为运行状态
鼠标移动			英雄机随着鼠标移动
鼠标移出			运行状态变为暂停状态
鼠标移入			暂停状态变为运行状态

MouseAdapter(抽象类) l = new MouseAdapter(){
	方法体---重写MouseMove()
};
this.addMouseListener(l);	//处理鼠标操作事件:鼠标点击/移出/移入
this.addMouseMotionListener(l); //处理鼠标滑动事件:鼠标移动

实现步骤:
1)敌人入场:
	1.1)在world类中添加nextOne()来随机生成敌人对象
	1.2)在run()调用enterAction()实现敌人入场
	1.3)在enterAction()中调用nextOne()来获取敌人
		并添加到enemies数组中(扩容,赋到最后一个)

2)飞行物移动:
	2.1)在超类FlyingObject中添加抽象方法step()
	2.2)在派生类中重写step()
	2.3)在World类的run()中调用stepAction()实现飞行物的移动
	2.4)在stepAction()中分别调用step()
	
3)子弹入场:
	3.1)在Hero英雄机中添加shoot()实现发射子弹
	3.2)在World类的run()中调用shootAction()实现子弹入场
	3.3)在shootAction()中获取英雄机发射出来的子弹对象
		并添加到bullets数组中(扩容,追加)

4)英雄机随着鼠标动:
	4.1)在Hero英雄机中添加moveTo()实现英雄机移动
	4.2)在World类中添加事件侦听器,重写mouseMoved()方法,
		在mouseMoved()中获取鼠标的x和y,
		调用moveTo(),实现英雄机随着鼠标动

5)删除越界的飞行物:
	5.1)在超类FlyingObject中设计抽象方法outOfBounds(),
		实现对象的越界检查
	5.2)在派生类中重写outOfBounds()
	5.3)在World类的run()中调用outOfBoundsAction(),
		实现对越界对象的删除
	5.4)在outOfBoundsAction()中:
		声明不越界的数组,遍历,判断若不越界
		则将对象存储在不越界数组中,复制			

6)子弹与敌人的碰撞:
	6.1)在超类FlyingObject中设计hit()实现敌人与子弹的碰撞
		在超类FlyingObject中设计goDead()让飞行物去死
		在英雄机Hero中设计addLife()增命,addDoubleFire()增火力
	6.2)在World类的run()中调用bulletBangAction()实现子弹与敌人的碰撞
	6.3)在bulletBangAction()中嵌套循环判断是否装上了
		若撞上了,敌人与子弹去死,判断被撞对象,得分或得奖励

7)画分和画命:g.drawString(str,x,y)

8)英雄机与敌人的碰撞:
	8.1)借用FlyingObject中的hit()碰撞和GoDead()去死
		在英雄机Hero中添加substractLife()减命,clearDoubleFire()清空火力值
	8.2)在World类的run()中调用heroBangAction()实现英雄机和敌人的碰撞
	8.3)在heroBangAction()中遍历所有敌人,与英雄机对比
		若撞上了,则敌人去死,英雄机减命,清空火力值
9)检测游戏结束:
	9.1)借用Hero中的getLife()获取英雄的生命值
	9.2)在World类的run()中调用checkGameOverAction()
	9.3)在checkGameOverAction()中判断游戏是否结束
		若游戏结束了,则修改当前状态为游戏结束状态
10)画状态:
	10.1)在World类中设计了4个常量表示程序的状态
	10.2)在World类中设计了3个静态常量表示启动图/暂停图/游戏结束图,并在static块中初始化
	10.3)在World类的paint()中在不同状态下画不同的图
	10.4)在World类的run()中的一堆action设计为在运行状态下
	10.5)在World类的鼠标移动事件中的英雄随着动设计为
	10.6)在World类中重写鼠标点击事件
	10.7)在World类中重写鼠标移出事件
	10.8)在World类中重写鼠标移入事件
	
-------------------------------------
oo.day08:
子弹与敌人的碰撞	
	
	
	
	
	
	
	
	
	
	
2) 		
 		
